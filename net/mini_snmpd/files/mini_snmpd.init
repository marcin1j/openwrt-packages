#!/bin/sh /etc/rc.common
# Copyright (C) 2009-2016 OpenWrt.org
# Copyright (C) 2016 Luke McKee <hojuruku@gmail.com>
# Procd init script reference: http://wiki.prplfoundation.org/wiki/Procd_reference

START=98
USE_PROCD=1
PROG=/usr/bin/mini_snmpd
NAME=mini_snmpd

_log() {
        logger -p daemon.info -t mini_snmpd "$@"
}

_err() {
        logger -p daemon.err -t mini_snmpd "$@"
}


# mini_snmpd 1.3+ now starts later in the game. Expects filesystems monitored to be already mounted, or wont pass args to mini_snmpd 
# and at least configuration entry for network physical interface defined in /etc/config/network
# It handles network interfaces not yet present (e.g. ppp) but will statfs() the root/wrong filesystem if device not mounted
# Tip: complex scripts run faster without in openwrt if you stop busybox forking and searching for applets. Faster bootups
#	CONFIG_BUSYBOX_CONFIG_FEATURE_SH_NOFORK
# 	CONFIG_BUSYBOX_CONFIG_FEATURE_PREFER_APPLETS
# 	BUSYBOX_CONFIG_ASH_OPTIMIZE_FOR_SIZE [=n]
#	CONFIG_BUSYBOX_CONFIG_ASH_CMDCMD

mini_snmpd_validation="enabled:bool:0 \
		ipv6:bool:0 \
		debug:bool:0 \
		auth:bool:1 \
		community:rangelength(1,32):public \
		contact:maxlength(255) \
		location:maxlength(255) \
		listen_interface:uciname \
		udp_port:port \
		tcp_port:port \
		vendor_oid:string \
		mib_timeout:and(min(1),uinteger) \
		disks:list(directory) \
		interfaces:list(uciname) \
		network_devices:list(string) \
		respawn_threshold:uinteger respawn_timeout:uinteger respawn_retry:uinteger"
# busybox ash has no array variable support, when put validations in a string be careful to have no spaces in each validate constraint
# this makes it very difficult to use the 'or(uciname, "all")' test, so listen_interface '' or undefined now meands bind to "all".
# this is the sarafice you have to make to avoid typing it all in twice in this script so we can give feedback to user on what's misconfigered
# in syslog

append_disk() {
	local disk="$1" disk_count
	[ -z $disk_count ] && disk_count=0

	grep -qF "$disk" /proc/mounts || {
		_err "$cfg: mountpoint $disk for snmp monitoring not mounted, ignoring."
		return
	}

	# check the fileystem is mountpoint, and directory search permissions available for statfs()
	# presence as a directory -d test done is already done by uci_validate_section()
	[ -x "$disk" ] || {
		_err "$cfg: mountpoint $disk for snmp monitoring EACCES error. Check permissions, ignoring"
		return 1
	}

	[ $disk_count -ge 4 ] && {
		_err "$cfg: more than 4 mountpoints defined in uci. Disc $disk ignored."
		return
	}

	append disks_arg "$disk" ','
	disk_count=$((disk_count++))
}

append_interface() {
	local name="$1" netdev netdev_count
	[ -z $netdev_count ] && netdev_count=0

	# for the purposes of snmp monitoring it doesn't need to be up, it just needs to exist in /proc/net/dev
	network_get_device netdev "$name"
	[ -n "$netdev" ] && grep -qF "$netdev" /proc/net/dev || {
		 _log "$cfg: physical interface for network $name not found in uci or kernel so not monitoring"
		 return
	}

	[ $netdev_count -ge 4 ] && {
		_err "$cfg: too many network interfaces configured, ignoring $name"
		return
	}

	append interfaces_arg "$netdev" ','
	netdev_count=$((netdev_count++))
}

append_netdev() {
	local netdev="$1" netdev_count
	[ -z $netdev_count ] && netdev_count=0

	grep -qF "$netdev" /proc/net/dev || {
		 _log "$cfg: interface $netdev not found so not monitoring"
		 return
	}

	[ $netdev_count -ge 4 ] && {
		_err "$cfg: too many network interfaces configured, ignoring $name"
		return
	}

	append interfaces_arg "$netdev" ','
	netdev_count=$((netdev_count++))
}

append_arg() {
	local var="$2"
	local opt="$1"
	[ -n "$var" ] && procd_append_param command $opt "$var"
}

watch_interfaces() {
	local cfg="$1"
	local enabled

	config_get_bool enabled "$cfg" "enabled" '1'
	[ "$enabled" -gt 0 ] || return 0

	config_get listen_interface "$cfg" listen_interface
	config_get reload_interfaces "$cfg" interfaces

}

validate_mini_snmpd_section() {
	uci_validate_section mini_snmpd mini_snmpd "${1}" $mini_snmpd_validation
}


service_triggers() {
	procd_add_reload_trigger 'mini_snmpd'
	procd_add_validation validate_mini_snmpd_section

        config_load 'mini_snmpd'
        config_foreach watch_interfaces 'mini_snmpd'

        [ -n "$listen_interface" ] && {
		# this only watches interfaces for which there is no running instance due to interface down / not in ubus
		# hence start not reload, this trigger will not affect running instances as another start will not change their procd command arguments
		# or stop the already running process
		procd_open_trigger
		procd_add_interface_trigger "interface.*" $n /etc/init.d/mini_snmpd start
		procd_close_trigger
	}

	for n in $reload_interfaces $listen_interface; do
		procd_add_reload_interface_trigger $n
	done
}


start_instance() {
	local cfg
	cfg="$1"
	local enabled ipv6 debug auth community contact location listen_interface \
		udp_port tcp_port vendor_oid mib_timeout disks interfaces
	local disks_arg interfaces_arg

	validate_mini_snmpd_section "$cfg" 2>/dev/null || {
		_err "validation of $NAME configuration for $cfg instance failed"
		return 1
	}

	[ "$enabled" == 1 ] || return 0

	local listen_interface_ip listen_interface_device
	[ -n "$listen_interface" ] && {
		if [ "$ipv6" = 1 ]; then
			network_get_ipaddrs6 listen_interface_ip "$listen_interface"
		else
			network_get_ipaddrs listen_interface_ip "$listen_interface"
		fi
		network_is_up "$listen_interface" && [ -n "$listen_interface_ip" ] || {
			_log "$cfg:listen interface $listen_interface not up yet / not configured properly"
			_log "$cfg:procd will try again when interface state changes"
			return 1
		}
		network_get_physdev listen_interface_device "$listen_interface"
	}

	config_list_foreach "$cfg" 'disks' append_disk
	config_list_foreach "$cfg" 'interfaces' append_interface
	config_list_foreach "$cfg" 'network_devices' append_netdev

	procd_open_instance

	procd_set_param command "$PROG" -n
 	procd_set_param stdout "1"
	procd_set_param stderr "1"

	append_arg "-c" "$community"
	append_arg "-L" "${location}"
	append_arg "-C" "${contact}"
	append_arg "-p" $udp_port
	append_arg "-P" $tcp_port
	append_arg "-V" "${vendor_oid}"
	append_arg "-t" $mib_timeout

	[ "$ipv6" = 1  ] && procd_append_param command "-6"
	[ "$debug" = 1 ] && procd_append_param command "-v"
	# uci_validate_section() aka /sbin/validate_data can only cast default values not defined in /etc/config/* to string
	# e.g. ="1" however it sets bools defined in /etc/config/* to =1 / =0
	[ "$auth" = 1 -o "$auth" = "1" ] && procd_append_param command "-a"
	[ -n "$disks_arg" ] && procd_append_param command "-d" "$disks_arg"
	[ -n "$interfaces_arg" ] && {
		procd_append_param command "-i" "$interfaces_arg"
		procd_append_param netdev ${interfaces_arg//,/ }
	}
	[ -n "$listen_interface_device" ] && {
		 procd_append_param command "-I" "$listen_interface_device"
		 procd_append_param netdev $listen_interface_device
	}
	procd_close_instance
}

start_service() {
	. /lib/functions.sh
	. /lib/functions/network.sh

	config_load 'mini_snmpd'
	config_foreach start_instance 'mini_snmpd'
}

